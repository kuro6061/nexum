"""
worker.py — Nexum worker for browser-use tasks.

Each EFFECT node runs a browser-use Agent to complete a browsing task.
COMPUTE nodes do local text processing (no browser needed).

Usage:
    python worker.py
"""

import asyncio
import json
import logging
import os

from pydantic import BaseModel
from nexum import workflow, NexumClient, Worker
from workflow import BrowseResult, Summary, Report

logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")
logger = logging.getLogger(__name__)

GEMINI_KEY = os.environ.get("GEMINI_API_KEY") or os.environ.get("GOOGLE_API_KEY")
OPENAI_KEY = os.environ.get("OPENAI_API_KEY")


def _get_llm():
    if GEMINI_KEY:
        from langchain_google_genai import ChatGoogleGenerativeAI
        return ChatGoogleGenerativeAI(model="gemini-2.0-flash", google_api_key=GEMINI_KEY)
    elif OPENAI_KEY:
        from langchain_openai import ChatOpenAI
        return ChatOpenAI(model="gpt-4o-mini", api_key=OPENAI_KEY)
    else:
        raise RuntimeError("Set GEMINI_API_KEY or OPENAI_API_KEY")


async def _run_browser_task(task: str) -> tuple[str, str]:
    """Run a browser-use Agent and return (content, url)."""
    from browser_use import Agent
    llm = _get_llm()
    agent = Agent(task=task, llm=llm)
    result = await agent.run()
    # browser-use result contains the final output
    content = str(result.final_result() or "")
    # Try to extract the URL from the last action
    url = ""
    try:
        history = result.history
        if history:
            last_url = history[-1].state.url if hasattr(history[-1], "state") else ""
            url = last_url or ""
    except Exception:
        pass
    return content, url


def research_handler(ctx):
    topic = ctx.input.get("topic", "AI agents")
    task = f"Search the web and find detailed information about: {topic}. Read the top 2-3 sources and summarize the key information."
    logger.info(f"Browsing: {task[:80]}")
    content, url = asyncio.get_event_loop().run_until_complete(_run_browser_task(task))
    return BrowseResult(content=content[:5000], url=url)


def summarize_handler(ctx):
    research_content = ctx.get("research").content
    topic = ctx.input.get("topic", "")
    # Local summarization — no browser needed
    lines = [l.strip() for l in research_content.split("\n") if l.strip()]
    key_points = [l for l in lines if len(l) > 20][:5]
    summary = f"Research summary on '{topic}':\n\n" + "\n".join(f"• {p}" for p in key_points[:3])
    return Summary(text=summary, key_points=key_points[:5])


def follow_up_handler(ctx):
    summary = ctx.get("summarize")
    topic = ctx.input.get("topic", "AI agents")
    # Browse for follow-up based on key points
    follow_up_query = f"Find recent developments and examples related to: {topic}. Focus on practical applications."
    if summary.key_points:
        follow_up_query += f" Specifically: {summary.key_points[0]}"
    logger.info(f"Follow-up browse: {follow_up_query[:80]}")
    content, url = asyncio.get_event_loop().run_until_complete(_run_browser_task(follow_up_query))
    return BrowseResult(content=content[:5000], url=url)


def report_handler(ctx):
    topic = ctx.input.get("topic", "AI agents")
    research = ctx.get("research")
    summary = ctx.get("summarize")
    follow_up = ctx.get("follow_up")

    report_content = f"""# Research Report: {topic}

## Summary
{summary.text}

## Key Findings
{chr(10).join(f'- {p}' for p in summary.key_points)}

## Follow-up Research
{follow_up.content[:1000]}

## Conclusion
This report was generated by browser-use + Nexum durable execution pipeline.
Each step was persisted atomically — crash recovery is automatic.
"""
    sources = [s for s in [research.url, follow_up.url] if s]
    return Report(title=f"Research Report: {topic}", content=report_content, sources=sources)


# Workflow with real handlers
browser_research_workflow = (
    workflow("browser-research")
    .effect("research", BrowseResult, handler=research_handler, depends_on=[])
    .compute("summarize", Summary, handler=summarize_handler, depends_on=["research"])
    .effect("follow_up", BrowseResult, handler=follow_up_handler, depends_on=["summarize"])
    .compute("report", Report, handler=report_handler, depends_on=["research", "summarize", "follow_up"])
    .build()
)


async def main():
    client = NexumClient()
    compat = client.register_workflow(browser_research_workflow)
    logger.info(f"Registered 'browser-research' workflow (compatibility: {compat})")
    logger.info("Worker started on localhost:50051 ...")
    w = Worker([browser_research_workflow], concurrency=1, poll_interval=0.5)
    w._running = True
    await w._run()


if __name__ == "__main__":
    asyncio.run(main())
